Nice work, man. This is a real system now, not a toy. I’ll go straight into what’s good structurally, then into the flaws, inconsistencies, and upgrade paths.

0. Big-picture: what’s working

I’m not going to waste time praising you, but you should know this:

Centralized accounting rules: accounts.ts is doing real work now — ranges, ACCOUNT_CODES, REHAB_CODES, helpers like isRentalIncomeCode, isFlipExpenseCode, isCashAccount, categorizeExpense. That’s the right direction for a serious system.

Tax logic is finally aligned with reality:

Rental income/expenses tracked separately with code ranges.

Flip expenses (62100–62105) are treated as capitalized flip costs, not Schedule C or E expenses.

Views instead of matviews like account_balances_v, ytd_income_v, ytd_expense_v, pending_transactions_v give you a nice read layer without complex refresh logic.

Ledger v2 looks solid conceptually: account filters, date presets, sorting, clear vs pending, etc.

Flip tooling (NewFlipTransaction, FlipSummary, FlipDetailView, REI view) is becoming its own subsystem — good separation.

Now the stuff that actually matters: the cracks.

1. Critical: Secrets and repo hygiene
1.1. pg_password.txt in the project

You have a literal password in pg_password.txt:

@L19862411ex!Carmen


And my_db_backup.ps1 explicitly loads it from the project root:

$PasswordFile = Join-Path $ROOT "pg_password.txt"
...
$env:PGPASSWORD = (Get-Content $PasswordFile -Raw).Trim()


Risk:

If this folder is ever committed or zipped and shared (which you just did), your DB credentials are out.

If you reuse similar patterns for other passwords, this is a habit that can burn you later.

Fix:

Add this to .gitignore (and make sure it actually exists):

pg_password.txt
*.sql
*.dump
db_debug/
db_backup/
debug_docs_*.zip


Rotate the DB password on Supabase. Assume it’s compromised.

Keep my_db_backup.ps1 but always generate pg_password.txt locally and never share it with anyone.

This is basic stewardship. You’re managing a system that will eventually hold 7+ years of business + personal history. Don’t make it easy for the wrong person.

2. Double-entry integrity: where you’re solid and where you’re exposed
2.1. DB-side function: create_transaction(...)

You have a PL/pgSQL function public.create_transaction(p_date, p_description, p_line1, p_line2) in logic_app_public.sql that:

Takes two JSON “lines”

Extracts amounts

Validates they’re not null

Inserts the parent row in public.transactions

Inserts two rows into transaction_lines

Returns JSON with transaction_id and date.

This is exactly what you want as a canonical path for normal two-line transactions.

2.2. Frontend usage: good path vs custom paths

Good path (canonical)

In NewTransactionForm.tsx you correctly use the RPC:

const { error: rpcErr } = await supabase.rpc('create_transaction', {
  p_date: date,
  p_description: description || null,
  p_line1: line1,
  p_line2: line2,
  p_purpose: txPurpose,
});


This is where you want most normal activity to flow.

Custom / bypass paths

You also have places where you bypass the RPC and write lines directly:

NewTransactionForm.tsx – handleFlipExpenseSubmit

You:

Insert parent transaction manually

Then insert two lines with supabase.from('transaction_lines').insert({...}) twice.

So for flip rehab expenses (the “shortcut” in the generic form), you’re not using create_transaction. It’s logically balanced (+amt, -amt), but:

There’s no DB-side enforcement that the sum per transaction = 0.

There’s no single-transaction guarantee unless you wrap in RPC/SQL.

If this logic ever gets more complex (three-way split, discount, etc.), you’re trusting frontend math.

Transfers.tsx

You:

const { error: lineError } = await supabase
  .from('transaction_lines')
  .insert([
    { transaction_id: transactionId, account_id: fromId, amount: -amt, is_cleared: true, purpose },
    { transaction_id: transactionId, account_id: toId,   amount:  amt, is_cleared: true, purpose },
  ]);


Better than the flip shortcut (at least both lines are in a single insert), but still:

No DB-level rule that “sum(amount) per transaction = 0”.

You rely on UI to prevent mistakes.

NewFlipTransaction.tsx

This one is more sophisticated:

It builds a full multi-line transaction for flip acquisitions, rehab, draws, sales.

It checks:

const total = lines.reduce((sum, l) => sum + l.amount, 0);
if (Math.abs(total) > 0.01) {
  throw new Error(`Transaction does not balance. Sum: ${total.toFixed(2)}`);
}


Then inserts all lines in one insert(lines) call.

This is logically sound and atomic at the statement level, but again: no DB-level invariant. If some other client or future code bypasses this pattern, you can silently corrupt the ledger.

2.3. What I would do differently

If this system is supposed to be your source of truth for tax and historical accounting, I wouldn’t trust “each component” to manually balance entries.

Concrete upgrade path:

Add a DB-level constraint/trigger on transaction_lines:

Either:

A deferred constraint or trigger that ensures SUM(amount) = 0 per transaction_id at statement/transaction commit for all transactions.

Or:

A design where no one inserts directly into transaction_lines except through RPC functions.

Introduce one canonical “multi-line” RPC, e.g.:

create_transaction_multi(p_date date, p_description text, p_lines jsonb[]) returns json


And move the NewFlipTransaction balancing logic into Postgres.

Update frontend:

NewTransactionForm (normal 2-line case) → still use create_transaction or call the multi-line create_transaction_multi with 2 lines.

Transfers → call multi-line RPC.

NewFlipTransaction → call multi-line RPC.

This keeps one brain responsible for double-entry: the database. That’s how serious systems do it.

3. Tax & classification logic – mostly correct, a bit duplicated
3.1. TaxExportView: flips vs rentals vs C vs personal

In TaxExportView.tsx:

You classify income:

if (accType === 'income') {
  if (purpose === 'business' || purpose === 'mixed') {
    if (isRentalIncomeCode(code)) → schedEIncomeMap
    else                           → schedCIncomeMap
  }
  // personal income ignored
}


You classify expenses:

else if (accType === 'expense') {
  if (purpose === 'business' || purpose === 'mixed') {
    if (isFlipExpenseCode(code)) {
      // Flip expenses – capital costs, not deductible yet
      flipExpenseMap
    } else if (isRentalExpenseCode(code)) {
      // Schedule E
      schedEExpenseMap
    } else {
      // Schedule C
      schedCExpenseMap
    }
  } else if (purpose === 'personal') {
    personalExpenseMap
  }
}


You then:

Export Schedule C, Schedule E, Flip Expenses (Not Sold), Personal Expenses.

Build a 1099 list for contractors with totalPaid >= 600.

That matches the structural correction we talked about:

Flips → basis, not current-year expense.

Rentals → Schedule E only.

Non-RE business → Schedule C.

Personal → tracked but separated.

This is correct given your account code ranges (ACCOUNT_CODE_RANGES) are accurate.

3.2. ProfitSummary & AnalyticsExpenses use similar logic, but duplicated

In ProfitSummary.tsx you do:

accType === 'income' → rental vs job via isRentalIncomeCode.

accType === 'expense' and:

if (isPersonal)                → bucket.personal
else if (isRealEstateExpenseCode) → bucket.reExpenses
else if (line.job_id !== null) → bucket.jobExpenses
else if (isMarketingExpenseCode) → bucket.marketing
else                           → bucket.overhead


In AnalyticsExpenses.tsx you do almost the same thing, just aggregating by account instead of month.

Problem: This classification logic is copy-pasted and not using your own categorizeExpense helper from accounts.ts.

You already wrote:

export type ExpenseCategory = 'realEstate' | 'marketing' | 'overhead' | 'jobExpense' | 'personal';

export function categorizeExpense(
  code: string | null | undefined,
  purpose: Purpose,
  hasJobId: boolean
): ExpenseCategory {
  if (purpose === 'personal') return 'personal';

  const isBusiness = purpose === 'business' || purpose === 'mixed';
  if (!isBusiness) return 'personal';

  if (isRealEstateExpenseCode(code)) return 'realEstate';
  if (hasJobId)                      return 'jobExpense';
  if (isMarketingExpenseCode(code))  return 'marketing';
  return 'overhead';
}


You are not using this in:

ProfitSummary.tsx

AnalyticsExpenses.tsx

DashboardOverview.tsx (YTD breakdown)

Risk: If you tweak classification in one place and forget others, your ProfitSummary, Analytics, and Tax exports can diverge from each other.

Upgrade:

Refactor classification in those components to call categorizeExpense(...) instead of duplicating logic.

That keeps your “business / RE / marketing / overhead / personal” theology in one place.

4. TypeScript issues & “any” leaks

You said you want drop-in-ready, typed code. There are a few obvious violations:

4.1. RawLineRow any in Transfers.tsx

You have:

type RawLineRow = {
  account_id: number;
  amount: number;
  accounts: any;
};


But your query is:

.select('account_id, amount, accounts(account_types(normal_side))')


So accounts is actually:

{
  account_types: { normal_side: string } | null;
} | null


You even operate on it as if that’s true. This is why you hit that earlier TS error and “fixed” it with any.

Fix (drop-in):

type RawLineRow = {
  account_id: number;
  amount: number;
  accounts: {
    account_types: { normal_side: string } | null;
  } | null;
};


And delete the accounts: any; hack.

4.2. Supabase results as any[]

Across multiple files:

AnalyticsBalances.tsx

AnalyticsExpenses.tsx

AnalyticsCashFlow.tsx

ProfitSummary.tsx

TaxExportView.tsx

InstallersOverview.tsx

LeadSourcesOverview.tsx

VendorsOverview.tsx

NewEntryView.tsx

NewFlipTransaction.tsx

etc.

You repeatedly do:

const { data, error } = await supabase.from('...').select(...);

const lines = (data ?? []) as any[];
for (const line of lines) {
  // assume structure
}


That’s fine for quick-and-dirty; it’s not what you said you want.

Better pattern:

For each query, define a typed shape that matches the select:

type LineRow = {
  id: number;
  amount: number;
  purpose: Purpose | null;
  account_id: number;
  accounts: {
    name: string;
    code: string | null;
    account_types: { name: string } | null;
  } | null;
  transactions: { date: string } | null;
};

const { data, error } = await supabase
  .from('transaction_lines')
  .select(`
    id,
    account_id,
    amount,
    purpose,
    accounts (
      name,
      code,
      account_types (name)
    ),
    transactions!inner (date)
  `);

const lines = (data ?? []) as LineRow[];


If you want to go next-level, you could define shared types for these common projections in a src/types/supabaseViews.ts.

4.3. Recharts any props

You have tooltips like:

const CustomTooltip = ({ active, payload }: any) => { ... };
const CashFlowTooltip = ({ active, payload, label }: any) => { ... };


Not critical for correctness, but it’s another signal you’re loosening the typing net. It’s fine to leave for now, but you could tighten them later with the Recharts TooltipPayload types.

5. Fragile coupling to account names

In NewTransactionForm.tsx you have this:

const laborAccount = accounts.find(a => a.name === 'RE – Flip Rehab Labor');
const materialsAccount = accounts.find(a => a.name === 'RE – Flip Rehab Materials');
let expenseAccountId = costType === 'L' && laborAccount ? laborAccount.id :
                       costType === 'M' && materialsAccount ? materialsAccount.id :
                       0;


And even:

const label = costType === 'L'
  ? 'RE – Flip Rehab Labor'
  : 'RE – Flip Rehab Materials';


You spent all this effort building ACCOUNT_CODES, REHAB_CODES, and ACCOUNT_CODE_RANGES, and then you hard-wire account names here.

If you ever rename those accounts in the DB (even slightly), this code silently breaks: wrong accounts, wrong classification, wrong tax export.

Fix (principle):

Never rely on name for business logic.

Use code + your centralized constants.

Concrete suggestion:

Use codes and ACCOUNT_CODES:

import { ACCOUNT_CODES } from '../utils/accounts';

const laborAccount = accounts.find(a => a.code === ACCOUNT_CODES.FLIP_REHAB_LABOR);
const materialsAccount = accounts.find(a => a.code === ACCOUNT_CODES.FLIP_REHAB_MATERIALS);


For labels, use a constant map in accounts.ts or in the component, but don’t reuse the DB name string as a magic key.

6. Analytics assumptions to sanity-check

These aren’t “bugs”, but I want to challenge the assumptions.

6.1. AnalyticsCashFlow.tsx ignores purpose

You do:

if (accType === 'income') {
  monthData.income += Math.abs(amount);
} else if (accType === 'expense') {
  monthData.expenses += Math.abs(amount);
}


There is:

No distinction between business vs personal.

No filtering on account code ranges.

So your “Cash Flow” lines will include everything that hits income/expense accounts, including personal spending if you ever coded some personal expense accounts as account_types.name = 'expense'.

Question for you (you don’t need to answer me, but you should answer yourself):

Do you want Analytics → Cash Flow to show overall life cash flow, or strictly business/rental cash flow?

If it’s business-only:

You should apply purpose filtering (business/mixed) and maybe drop personal.

If it’s life-wide:

Keep it as is, but label it clearly in the UI (“All accounts” vs “Business only”).

Right now, the logic and naming don’t make that distinction explicit.

6.2. Month boundaries & timezone

You often do:

const d = new Date(dateStr + 'T00:00:00');
const month = d.getMonth();
const year = d.getFullYear();


Using local time. For your use case, this is probably fine (dates are just dates, not timezone-sensitive timestamps), but:

If Supabase ever stores these as timestamp with time zone, you can get off-by-one-day issues.

For taxes and year buckets, you want calendar date semantics, not timezone semantics.

Just be aware. If this ever bites, the fix is to treat dates as pure strings (YYYY-MM-DD) and avoid Date for bucketing.

7. Redundancies and structural polish
7.1. Real estate types defined in multiple places

I see variants of:

type RealEstateDeal = { ... };


in:

DashboardOverview.tsx

DealEditView.tsx

NewTransactionForm.tsx

And then other deal-shaped types in FlipSummary, FlipDetailView, etc., which are all describing the same conceptual entity with slightly different fields.

Better:

Create src/types/realEstate.ts with canonical types:

RealEstateDealBase (core DB fields)

RealEstateDealWithMetrics (aggregates like rehab_spent, grossProfit, etc.)

Reuse those across components instead of redefining ad hoc shapes.

This will matter when you add new fields (e.g., HOA, utilities, staging, agent splits) and don’t want 5 components drifting out of sync.

7.2. index.ts vs index__1.ts

You have:

index.ts as the ledger barrel:

// src/components/ledger/index.ts
export { LedgerView } from './LedgerView';
export { LedgerEditModal } from './LedgerEditModal';
export { LedgerClearModal } from './LedgerClearModal';
export { LedgerFilters } from './LedgerFilters';
export { LedgerTable } from './LedgerTable';
export * from './types';
export * from './utils';


index__1.ts as a mobile barrel:

// Mobile components barrel export
export { MobileContainer } from './MobileContainer';
export { JobsTab } from './JobsTab';
export { PricesTab } from './PricesTab';
export { mobileStyles, TX_COLORS } from './mobileStyles';


This is just confusing. Index files should be around folders, not aliases.

I’d:

Put the mobile stuff in src/mobile/index.ts.

Delete/rename index__1.ts.

Keep src/components/ledger/index.ts as the ledger barrel.

Less ambiguity, easier imports.

8. Smaller things worth tightening

Rapid-fire list:

CODING_RULES.txt vs reality
The rules mention specific paths like src/utils/accounts.ts and emphasize using those helpers. In the code, some imports reference ../../utils/accounts, some comments say // src/accounts.ts. Make sure the actual directory structure matches the rules and you’re not drifting.

sample_data.sql and schema_core.sql
These are fine to keep, but be careful:

Don’t ship real client/vendor names or sensitive PII.

Keep them out of any public repo.

Consider an anonymized sample dump for demos/tests, and a private real dump for yourself.

“Loading…” UX
In App.tsx and some views, you’ve done simple “Loading…” divs. That’s fine for now, but as the app grows, you’ll want a consistent spinner/skeleton component you reuse everywhere.

Magic numbers / thresholds

The 1099 threshold >= 600 is correctly hardcoded in TaxExportView for contractors. That’s law-based, but if this ever changes, you’ll be hunting for a literal 600. Consider a small TAX_CONSTANTS object for things like this (even if it’s just one value right now).

9. Summary: priority list

If I were you, I’d tackle in this order:

Security

Rotate Supabase password.

Ensure pg_password.txt is in .gitignore and never shared again.

Double-entry guarantees

Design and implement a single multi-line transaction RPC.

Move NewFlipTransaction, Transfers, and any special cases onto that path.

Optionally add a DB-level check/trigger to enforce SUM(amount) = 0 per transaction_id.

Classification DRYness

Refactor ProfitSummary, AnalyticsExpenses, DashboardOverview to use categorizeExpense + existing code helpers.

Keep tax logic, profit logic, and analytics logic all hanging from the same tree.

Types & “any”

Fix RawLineRow in Transfers.tsx.

Start replacing as any[] with explicit row interfaces for your main Supabase queries (ledger, profit, analytics, tax).

Fragile coupling to names

Replace string-name lookups like 'RE – Flip Rehab Labor' with code-based lookups using ACCOUNT_CODES.

Structural clean-up

Centralize real estate types.

Clean up index__1.ts vs real barrels.

If we tackle these one by one, you’ll end up with a system that’s not just “working”, but actually hard to break — even by your future self on a tired day.

If you want, next step we can:

Design the create_transaction_multi RPC together, and

Refactor one of the front-end components (e.g., Transfers.tsx) into that pattern as a drop-in.